{
  "title": "var myObject = {     foo: \"bar\",     func: function() {         var self = this;         console.log(\"outer func:  this.foo = \" + this.foo);         console.log(\"outer func:  self.foo = \" + self.foo);         (function() {             console.log(\"inner func:  this.foo = \" + this.foo);             console.log(\"inner func:  self.foo = \" + self.foo);         }());     } }; myObject.func();",
  "cells": [
    {
      "type": "code",
      "language": "javascript",
      "data": "var myObject = {\n    foo: \"bar\",\n    func: function() {\n        var self = this;\n        console.log(\"outer func:  this.foo = \" + this.foo);\n        console.log(\"outer func:  self.foo = \" + self.foo);\n        (function() {\n            console.log(\"inner func:  this.foo = \" + this.foo);\n            console.log(\"inner func:  self.foo = \" + self.foo);\n        }());\n    }\n};\nmyObject.func();\n\n\nThe above code will output the following to the console:\n\nouter func:  this.foo = bar\nouter func:  self.foo = bar\ninner func:  this.foo = undefined\ninner func:  self.foo = bar\nIn the outer function, both this and self refer to myObject and therefore both can properly reference and access foo.\n\nIn the inner function, though, this no longer refers to myObject. As a result, this.foo is undefined in the inner function, whereas the reference to the local variable self remains in scope and is accessible there."
    }
  ]
}