{
  "title": "Unit Testing",
  "cells": [
    {
      "type": "code",
      "language": "markdown",
      "data": "\nShawn Bullock [1:11 PM]  \nThere's two schools of unit testing thought.  1) use mocks, 2) don't.  This is heavily environment dependent but when testing API's I don't use Mocks nor has any team I've worked with, except: if hitting an API that has a cost associated to it such as a 3rd party or a live system.  In this sense, it's more like integration tests because it'll hit a server and mess with the data/file system.  That's okay.  If you have enough automation in place you can just spin up a new environment that is clean.  It's one thing to know that you're routes and endpoints function, its a whole other thing to know that they do the right thing (or wrong thing) when expected.\n\nThe main problem I had in the past with using Mocks is that is is too easy to become comfortable with sending back fake data to the point where the team becomes lazy and doesn't test enough realistic scenarios as the system evolves.  We had times where everything passed but the database was poorly integrated in reality, didn't catch it because it wasn't tested.  Then you end up with a 2nd set of tests to hit the system without mocks when you need to actually *really* test it.  (two tests unless sending the same data into the stub and the real, and expecting the same data in return which in reality, rarely was the case). No team I worked on had that kind of discipline (and in the last 15 years the smallest team I worked with was 60 developers on a single product base, the largest 236).  I admit, it's an issue of team discipline and knowing what you're doing more than a fault of mocking.  This is one of those topics where its hard to get right across the board.  Also another factor, all the code bases I worked on existed before the adoption of unit testing/mocking so it was hard to go back and retrofit the system.\n\nWhen our checkins were gated and no code was accepted that didn't first fully compile and second pass all tests, it took upwards of 4 hours for each checkin to be completed but we were able to bring it down to about 35 minutes which is acceptable.  Even at 4 hours we valued quality over quantity.  Over time I grew to prefer testing against the system rather than stubs and contrived data, and I think that's because we had a very large system where every action communicated with multiple services to get anything done so it was nigh impossible to rely on mocks to get the right stuff done.\n\nSo to answer your question, even with NodeJS, I prefer to test against the API without mocking\n\n it's a fine line, one I spent years trying to answer before I made a decision about it.  Unit Tests, or testing in general, absolutely should have cases for known good/bad states of environment (such as service down, unauthorized to use service, disk full, etc., all the things that can trip up a dependency).  BUT... focusing too much on \"happy paths\" (or known paths) is detrimental.  Should a unit test itself do error conditioning?  In general no, because of the nature (and definition) of what a Unit Test is.  We generally like to have a different test named for whatever it does, but I like fewer tests with more realism.  Its testing only a function, roughly.  Integration tests are testing integrations but still just as granular.  However, my units are larger than most and DO detect these kinds of things when hitting something with obvious dependencies."
    }
  ]
}